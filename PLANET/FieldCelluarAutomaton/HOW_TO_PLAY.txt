Use the textbox under the grid to write rules and execute commands.
Check EXAMPLES.txt


==== RULES ====

syntax:
	R<name>: <expression>
example:
	R1: r
	R_random: r

name syntax: 
	regex: [\p{L}0-9_]+
	any sequence with UTF letters,digits,underscore

	example names:
	//	R1A , RA1_ R_A, R„ÅÇ Raaaa
	invalid:
		R! , R

expressions:
	each <EXPRESSION> evaluates to complex number
		logic values are complex numbers as well
	expressions evaluate left-to-right
		2 + 2 * 2 -> 8
		2 + (2 * 2) -> 6
	
	An <EXPRESSION> is any of following:
		<COMPLEX>
		<FUNCTION>
		<LOGICAL_VALUE>
		<BINARY_OPERATION>
		(<EXPRESSION>)

	<COMPLEX> - a complex number literal
		syntax:
			<REAL>+<IMAGINARY>i
			<REAL>+<IMAGINARY>i
			<REAL>
			<IMAGINARY>i
		example:
			1+4i
			-0.4-1.3i
			5
			1i
		note:
			i - is invalid


	<FUNCTION>:
		r - random unit complex number
		x - cell position
		p(<EXPRESSION>) - relative cell value
			p(-1) - returns value of left on the left - relative offset (-1, 0)
		c(<RULE>, <EXPRESSION>) - applies rule, on relative offset cell - returns value from rule
		n(<RULE>) - returns how many neighbour cells (3x3 grid) satisfy logic rule
			i.e. n(R1,4) neighbour cells satisfy R1 -> returns 4+4i
		?(<EXPRESSION>, <EXPRESSION>, <EXPRESSION>) - ?(condition, trueExpr, falseExpr) when condition is logical false, return falseExpr, otherwise returns trueExpr
			?(x = 5+5i, 1i, 1) - sets 1i on (5,5) cell and 1 on all others 
		m(<EXPRESSION>) - returns magnitude of expression
			m(2+2i) = sqrt(2^2 + 2^2) + 0i
		u(<EXPRESSION>) - returns unit vector of expression
			u(5) = 0.707 + 0.707i
			u(1+1i) = sqrt(2)
	<LOGICAL_VALUE>
		true
			represent 1+1i
		false
			represent 0+0i
		any non-false value is logical true

	<BINARY_OPERATION>

		-- MATH ---
		<EXPRESSION> + <EXPRESSION>
			note spacing:
				2+3i - is <COMPLEX>
				2 + 3i - is expression <COMPLEX> + <COMPLEX>, which evaluates to <COMPLEX>
		<EXPRESSION> - <EXPRESSION>
		<EXPRESSION> * <EXPRESSION> - complex multiplication
		<EXPRESSION> / <EXPRESSION> - complex division

		-- BINARY ---
		operate on logical values
			<EXPRESSION> and <EXPRESSION>
			<EXPRESSION> or <EXPRESSION>
			<EXPRESSION> xor <EXPRESSION>

		-- EQUALITY ---
			<EXPRESSION> = <EXPRESSION>
			<EXPRESSION> != <EXPRESSION>

		-- RELATIONAL ---
		operate on real part 
			<EXPRESSION> > <EXPRESSION>
			<EXPRESSION> >= <EXPRESSION>
			<EXPRESSION> < <EXPRESSION>
			<EXPRESSION> =< <EXPRESSION>


==== COMMAND ====

-- game flow ---
s[tep] - advance on selected rule
r[ule] R<x> - select rule
a[pply] R<x> - apply rule
p[lay]/start - run simulation
stop/stp - stop simulation
clear/clr/cls - clear board and rules


new - clear game
new <X> - square grid
	new 10 - 10x10 grid
new <X> <Y> - new X,Y rectangle grid
	new 10 5 10x5 grid
c[ell] X Y - select cell

disp[lay] <n[umber]/b[oolean]/a[rrow]> - change cell display
t[ype] <c[hecked]/w[rapped]> - change board type
	checked - all values beyond is zero (0+0i)
	wrapped - board is connected to opposite sides

save [name] - save to save directory (default quicksave)
load [name] - load from directory

jump - encourage app to jump
exit - exit app


